# newtype-uuid-macros

Procedural macros for the `newtype-uuid` crate.

This crate provides the `impl_typed_uuid_kinds!` macro for generating typed UUID kinds with compile-time type safety.

## Usage

The macro uses a structured format powered by `serde_tokenstream`:

```rust
use newtype_uuid_macros::impl_typed_uuid_kinds;

impl_typed_uuid_kinds! {
    settings = {
        schemars08 = {
            feature = "schemars08",
            rust_type = {
                crate = "my-service",
                version = "1.0.0",
                path = "my_service::types",
            },
        },
    },
    kinds = {
        User = {},
        Organization = {},
        Project = {},
        Task = {},
    }
}
```

This generates:

- `UserKind` enum implementing `TypedUuidKind` with tag `"user"`
- `UserUuid` type alias for `TypedUuid<UserKind>`
- `OrganizationKind` enum implementing `TypedUuidKind` with tag `"organization"`
- `OrganizationUuid` type alias for `TypedUuid<OrganizationKind>`
- And so on for each kind...

## Tag Generation

Tags are automatically generated by converting the kind name from PascalCase to snake_case using the `heck` crate:

- `User` → `"user"`
- `Organization` → `"organization"`
- `UserAccount` → `"user_account"`
- `HTTPClient` → `"http_client"`
- `XMLParser` → `"xml_parser"`

## Features

- `schemars08`: Enables hand-written `JsonSchema` implementations with `x-rust-type` extensions
- `v4`: Enables UUID v4 generation support for examples and tests

## Settings

The macro supports optional settings for configuring code generation:

### `schemars08` Settings

When provided, generates hand-written `JsonSchema` implementations for each kind with the following properties:

- **`feature`**: The Rust feature flag that gates the JsonSchema implementation
- **`rust_type.crate`**: The crate name for the `x-rust-type` extension
- **`rust_type.version`**: The version string for the `x-rust-type` extension  
- **`rust_type.path`**: The module path prefix for the generated types

Example:

```rust
impl_typed_uuid_kinds! {
    settings = {
        schemars08 = {
            feature = "schemars08",
            rust_type = {
                crate = "my-service",
                version = "1.0.0", 
                path = "my_service::types",
            },
        },
    },
    kinds = {
        User = {},
        APIKey = {},
    }
}
```

This generates JsonSchema implementations that produce schemas like:

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "User",
  "type": "string",
  "format": "uuid",
  "x-rust-type": {
    "crate": "my-service",
    "version": "1.0.0",
    "path": "my_service::types::UserKind"
  }
}
```

The `x-rust-type` extension is compatible with [typify](https://github.com/oxidecomputer/typify) and other code generation tools.

## Example

```rust
use newtype_uuid::{GenericUuid, TypedUuidKind};
use newtype_uuid_macros::impl_typed_uuid_kinds;

impl_typed_uuid_kinds! {
    kinds = {
        User = {},
        Organization = {},
    }
}

fn main() {
    // Create typed UUIDs
    let user_uuid = UserUuid::from_untyped_uuid(uuid::Uuid::new_v4());
    let org_uuid = OrganizationUuid::from_untyped_uuid(uuid::Uuid::new_v4());
    
    // Tags are automatically generated
    assert_eq!(UserKind::tag().as_str(), "user");
    assert_eq!(OrganizationKind::tag().as_str(), "organization");
    
    // Type safety is enforced at compile time
    // This would be a compile error:
    // let _error: UserUuid = org_uuid;
}
```

## Comparison with Declarative Macro

This procedural macro replaces the declarative macro pattern:

```rust
// Old declarative macro style
macro_rules! impl_typed_uuid_kind {
    ($($kind:ident => $tag:literal),* $(,)?) => { /* ... */ }
}

impl_typed_uuid_kind! {
    User => "user",
    Organization => "organization",
}

// New procedural macro style
impl_typed_uuid_kinds! {
    kinds = {
        User = {},
        Organization = {},
    }
}
```

The procedural macro provides:
- Automatic tag generation using the `heck` crate for robust case conversion
- Hand-written JsonSchema implementations with `x-rust-type` extensions (when configured)
- More structured syntax using `serde_tokenstream`
- Better error messages
- Extensibility for future per-kind configuration options