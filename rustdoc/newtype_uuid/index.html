<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A newtype wrapper around `Uuid`."><title>newtype_uuid - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-aa0817cf.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="newtype_uuid" data-themes="" data-resource-suffix="" data-rustdoc-version="1.90.0 (1159e78c4 2025-09-14)" data-channel="1.90.0" data-search-js="search-fa3e91e5.js" data-settings-js="settings-5514c975.js" ><script src="../static.files/storage-68b7e25d.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-eebb9057.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-32bb7600.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../newtype_uuid/index.html">newtype_<wbr>uuid</a><span class="version">1.3.1</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#motivation" title="Motivation">Motivation</a></li><li><a href="#example" title="Example">Example</a></li><li><a href="#implementations-1" title="Implementations">Implementations</a></li><li><a href="#dependencies" title="Dependencies">Dependencies</a></li><li><a href="#features" title="Features">Features</a></li><li><a href="#minimum-supported-rust-version-msrv" title="Minimum supported Rust version (MSRV)">Minimum supported Rust version (MSRV)</a></li><li><a href="#alternatives" title="Alternatives">Alternatives</a></li></ul><h3><a href="#structs">Crate Items</a></h3><ul class="block"><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#traits" title="Traits">Traits</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>newtype_uuid</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/newtype_uuid/lib.rs.html#1-954">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A newtype wrapper around <a href="https://docs.rs/uuid/1.18.1/uuid/struct.Uuid.html" title="struct uuid::Uuid"><code>Uuid</code></a>.</p>
<h2 id="motivation"><a class="doc-anchor" href="#motivation">ยง</a>Motivation</h2>
<p>Many large systems use UUIDs as unique identifiers for various entities. However, the <a href="https://docs.rs/uuid/1.18.1/uuid/struct.Uuid.html" title="struct uuid::Uuid"><code>Uuid</code></a>
type does not carry information about the kind of entity it identifies, which can lead to mixing
up different types of UUIDs at runtime.</p>
<p>This crate provides a wrapper type around <a href="https://docs.rs/uuid/1.18.1/uuid/struct.Uuid.html" title="struct uuid::Uuid"><code>Uuid</code></a> that allows you to specify the kind of entity
the UUID identifies.</p>
<h2 id="example"><a class="doc-anchor" href="#example">ยง</a>Example</h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>newtype_uuid::{GenericUuid, TypedUuid, TypedUuidKind, TypedUuidTag};

<span class="comment">// First, define a type that represents the kind of UUID this is.
</span><span class="kw">enum </span>MyKind {}

<span class="kw">impl </span>TypedUuidKind <span class="kw">for </span>MyKind {
    <span class="kw">fn </span>tag() -&gt; TypedUuidTag {
        <span class="comment">// Tags are required to be ASCII identifiers, with underscores
        // and dashes also supported. The validity of a tag can be checked
        // at compile time by assigning it to a const, like so:
        </span><span class="kw">const </span>TAG: TypedUuidTag = TypedUuidTag::new(<span class="string">"my_kind"</span>);
        TAG
    }
}

<span class="comment">// Now, a UUID can be created with this kind.
</span><span class="kw">let </span>uuid: TypedUuid&lt;MyKind&gt; = <span class="string">"dffc3068-1cd6-47d5-b2f3-636b41b07084"</span>.parse().unwrap();

<span class="comment">// The Display (and therefore ToString) impls still show the same value.
</span><span class="macro">assert_eq!</span>(uuid.to_string(), <span class="string">"dffc3068-1cd6-47d5-b2f3-636b41b07084"</span>);

<span class="comment">// The Debug impl will show the tag as well.
</span><span class="macro">assert_eq!</span>(
    <span class="macro">format!</span>(<span class="string">"{:?}"</span>, uuid),
    <span class="string">"dffc3068-1cd6-47d5-b2f3-636b41b07084 (my_kind)"
</span>);</code></pre></div>
<p>If you have a large number of UUID kinds, consider using
<a href="https://docs.rs/newtype-uuid-macros"><code>newtype-uuid-macros</code></a> which comes with several convenience features.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>newtype_uuid_macros::impl_typed_uuid_kinds;

<span class="comment">// Invoke this macro with:
</span><span class="macro">impl_typed_uuid_kinds!</span> {
    kinds = {
        User = {},
        Project = {},
        <span class="comment">// ...
    </span>},
}</code></pre></div>
<p>See <a href="https://docs.rs/newtype-uuid-macros"><code>newtype-uuid-macros</code></a> for more information.</p>
<p>For simpler cases, you can also write your own declarative macro. Use this
template to get started:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">macro_rules!</span> impl_kinds {
    ($(<span class="macro-nonterminal">$kind</span>:ident =&gt; <span class="macro-nonterminal">$tag</span>:literal),* $(,)<span class="question-mark">?</span>) =&gt; {
        $(
            <span class="kw">pub enum </span><span class="macro-nonterminal">$kind </span>{}

            <span class="kw">impl </span>TypedUuidKind <span class="kw">for </span><span class="macro-nonterminal">$kind </span>{
                <span class="attr">#[inline]
                </span><span class="kw">fn </span>tag() -&gt; TypedUuidTag {
                    <span class="kw">const </span>TAG: TypedUuidTag = TypedUuidTag::new(<span class="macro-nonterminal">$tag</span>);
                    TAG
                }
            }
        )*
    };
}

<span class="comment">// Invoke this macro with:
</span><span class="macro">impl_kinds!</span> {
    UserKind =&gt; <span class="string">"user"</span>,
    ProjectKind =&gt; <span class="string">"project"</span>,
}</code></pre></div>
<h2 id="implementations-1"><a class="doc-anchor" href="#implementations-1">ยง</a>Implementations</h2>
<p>In general, <a href="struct.TypedUuid.html" title="struct newtype_uuid::TypedUuid"><code>TypedUuid</code></a> uses the same wire and serialization formats as <a href="https://docs.rs/uuid/1.18.1/uuid/struct.Uuid.html" title="struct uuid::Uuid"><code>Uuid</code></a>. This means
that persistent representations of <a href="struct.TypedUuid.html" title="struct newtype_uuid::TypedUuid"><code>TypedUuid</code></a> are the same as <a href="https://docs.rs/uuid/1.18.1/uuid/struct.Uuid.html" title="struct uuid::Uuid"><code>Uuid</code></a>; <a href="struct.TypedUuid.html" title="struct newtype_uuid::TypedUuid"><code>TypedUuid</code></a> is
intended to be helpful within Rust code, not across serialization boundaries.</p>
<ul>
<li>The <code>Display</code> and <code>FromStr</code> impls are forwarded to the underlying <a href="https://docs.rs/uuid/1.18.1/uuid/struct.Uuid.html" title="struct uuid::Uuid"><code>Uuid</code></a>.</li>
<li>If the <code>serde</code> feature is enabled, <code>TypedUuid</code> will serialize and deserialize using the same
format as <a href="https://docs.rs/uuid/1.18.1/uuid/struct.Uuid.html" title="struct uuid::Uuid"><code>Uuid</code></a>.</li>
<li>If the <code>schemars08</code> feature is enabled, <a href="struct.TypedUuid.html" title="struct newtype_uuid::TypedUuid"><code>TypedUuid</code></a> will implement <code>JsonSchema</code> if the
corresponding <a href="trait.TypedUuidKind.html" title="trait newtype_uuid::TypedUuidKind"><code>TypedUuidKind</code></a> implements <code>JsonSchema</code>.</li>
</ul>
<p>To abstract over typed and untyped UUIDs, the <a href="trait.GenericUuid.html" title="trait newtype_uuid::GenericUuid"><code>GenericUuid</code></a> trait is provided. This trait also
permits conversions between typed and untyped UUIDs.</p>
<h2 id="dependencies"><a class="doc-anchor" href="#dependencies">ยง</a>Dependencies</h2>
<ul>
<li>The only required dependency is the <a href="https://docs.rs/uuid/1.18.1/uuid/index.html" title="mod uuid"><code>uuid</code></a> crate. Optional features may add further
dependencies.</li>
</ul>
<h2 id="features"><a class="doc-anchor" href="#features">ยง</a>Features</h2>
<ul>
<li><code>default</code>: Enables default features in the newtype-uuid crate.</li>
<li><code>std</code>: Enables the use of the standard library. <em>Enabled by default.</em></li>
<li><code>serde</code>: Enables serialization and deserialization support via Serde. <em>Not enabled by
default.</em></li>
<li><code>v4</code>: Enables the <code>new_v4</code> method for generating UUIDs. <em>Not enabled by default.</em></li>
<li><code>schemars08</code>: Enables support for generating JSON schemas via schemars 0.8. <em>Not enabled by
default.</em> Note that the format of the generated schema is <strong>not currently part</strong> of the stable
API, though we hope to stabilize it in the future.</li>
<li><code>proptest1</code>: Enables support for generating <code>proptest::Arbitrary</code> instances of UUIDs. <em>Not enabled by default.</em></li>
</ul>
<h2 id="minimum-supported-rust-version-msrv"><a class="doc-anchor" href="#minimum-supported-rust-version-msrv">ยง</a>Minimum supported Rust version (MSRV)</h2>
<p>The MSRV of this crate is <strong>Rust 1.79.</strong> In general, this crate will follow the MSRV of the
underlying <code>uuid</code> crate or of dependencies, with an aim to be conservative.</p>
<p>Within the 1.x series, MSRV updates will be accompanied by a minor version bump. The MSRVs for
each minor version are:</p>
<ul>
<li>Version <strong>1.0.x</strong>: Rust 1.60.</li>
<li>Version <strong>1.1.x</strong>: Rust 1.61. This permits <code>TypedUuid&lt;T&gt;</code> to have <code>const fn</code> methods.</li>
<li>Version <strong>1.2.x</strong>: Rust 1.67, required by some dependency updates.</li>
<li>Version <strong>1.3.x</strong>: Rust 1.79, required by some dependency updates.</li>
</ul>
<h2 id="alternatives"><a class="doc-anchor" href="#alternatives">ยง</a>Alternatives</h2>
<ul>
<li><a href="https://crates.io/crates/typed-uuid"><code>typed-uuid</code></a>: generally similar, but with a few design
decisions that are different.</li>
</ul>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">ยง</a></h2><dl class="item-table"><dt><a class="struct" href="struct.ParseError.html" title="struct newtype_uuid::ParseError">Parse<wbr>Error</a></dt><dd>An error that occurred while parsing a <a href="struct.TypedUuid.html" title="struct newtype_uuid::TypedUuid"><code>TypedUuid</code></a>.</dd><dt><a class="struct" href="struct.TagError.html" title="struct newtype_uuid::TagError">TagError</a></dt><dd>An error that occurred while creating a <a href="struct.TypedUuidTag.html" title="struct newtype_uuid::TypedUuidTag"><code>TypedUuidTag</code></a>.</dd><dt><a class="struct" href="struct.Timestamp.html" title="struct newtype_uuid::Timestamp">Timestamp</a></dt><dd>A timestamp that can be encoded into a UUID.</dd><dt><a class="struct" href="struct.TypedUuid.html" title="struct newtype_uuid::TypedUuid">Typed<wbr>Uuid</a></dt><dd>A UUID with type-level information about what itโs used for.</dd><dt><a class="struct" href="struct.TypedUuidTag.html" title="struct newtype_uuid::TypedUuidTag">Typed<wbr>Uuid<wbr>Tag</a></dt><dd>Describes what kind of <a href="struct.TypedUuid.html" title="struct newtype_uuid::TypedUuid"><code>TypedUuid</code></a> something is.</dd></dl><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">ยง</a></h2><dl class="item-table"><dt><a class="trait" href="trait.GenericUuid.html" title="trait newtype_uuid::GenericUuid">Generic<wbr>Uuid</a></dt><dd>A trait abstracting over typed and untyped UUIDs.</dd><dt><a class="trait" href="trait.TypedUuidKind.html" title="trait newtype_uuid::TypedUuidKind">Typed<wbr>Uuid<wbr>Kind</a></dt><dd>Represents marker types that can be used as a type parameter for <a href="struct.TypedUuid.html" title="struct newtype_uuid::TypedUuid"><code>TypedUuid</code></a>.</dd></dl></section></div></main></body></html>